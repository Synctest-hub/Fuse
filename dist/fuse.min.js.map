{"version":3,"file":"fuse.es6.min.js","sources":["../src/search/bitap-search/bitap-score.js","../src/search/bitap-search/constants.js","../src/search/bitap-search/index.js","../src/search/bitap-search/bitap-pattern-alphabet.js","../src/search/bitap-search/bitap-search.js","../src/search/bitap-search/bitap-matched-indices.js","../src/search/extended-search/exact-match.js","../src/search/extended-search/inverse-exact-match.js","../src/search/extended-search/prefix-exact-match.js","../src/search/extended-search/inverse-prefix-exact-match.js","../src/search/extended-search/suffix-exact-match.js","../src/search/extended-search/inverse-suffix-exact-match.js","../src/helpers/type-checkers.js","../src/search/extended-search/index.js","../src/search/ngram-search/ngram.js","../src/search/ngram-search/distance/jaccard-distance.js","../src/search/ngram-search/array-utils/union.js","../src/search/ngram-search/array-utils/intersection.js","../src/search/ngram-search/index.js","../src/search/index.js","../src/helpers/get.js","../src/tools/create-index.js","../src/tools/key-store.js","../src/tools/index.js","../src/transform/transform-matches.js","../src/index.js","../src/transform/transform-score.js"],"sourcesContent":["module.exports = (pattern, { errors = 0, currentLocation = 0, expectedLocation = 0, distance = 100 }) => {\n  const accuracy = errors / pattern.length\n  const proximity = Math.abs(expectedLocation - currentLocation)\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + (proximity / distance)\n}\n","// Machine word size\nmodule.exports.MAX_BITS = 32","const bitapSearch = require('./bitap-search')\nconst patternAlphabet = require('./bitap-pattern-alphabet')\nconst { MAX_BITS } = require('./constants')\n\nclass BitapSearch {\n  constructor(pattern, {\n    // Approximately where in the text is the pattern expected to be found?\n    location = 0,\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance = 100,\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold = 0.6,\n    // Indicates whether comparisons should be case sensitive.\n    isCaseSensitive = false,\n    // When true, the algorithm continues searching to the end of the input even if a perfect\n    // match is found before the end of the same input.\n    findAllMatches = false,\n    // Minimum number of characters that must be matched before a result is considered a match\n    minMatchCharLength = 1,\n\n    includeMatches = false\n  }) {\n    this.options = {\n      location,\n      distance,\n      threshold,\n      isCaseSensitive,\n      findAllMatches,\n      includeMatches,\n      minMatchCharLength\n    }\n\n    if (pattern.length > MAX_BITS) {\n      throw new Error(`Pattern length exceeds max of ${MAX_BITS}.`);\n    }\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase()\n    this.patternAlphabet = patternAlphabet(this.pattern)\n  }\n\n  searchIn(value) {\n    let text = value.$\n    return this.searchInString(text)\n  }\n\n  searchInString(text) {\n    const { isCaseSensitive, includeMatches } = this.options\n\n    if (!isCaseSensitive) {\n      text = text.toLowerCase()\n    }\n\n    // Exact match\n    if (this.pattern === text) {\n      let result = {\n        isMatch: true,\n        score: 0\n      }\n\n      if (includeMatches) {\n        result.matchedIndices = [[0, text.length - 1]]\n      }\n\n      return result\n    }\n\n    // Otherwise, use Bitap algorithm\n    const { location, distance, threshold, findAllMatches, minMatchCharLength } = this.options\n    return bitapSearch(text, this.pattern, this.patternAlphabet, {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength,\n      includeMatches\n    })\n  }\n}\n\nmodule.exports = BitapSearch\n","module.exports = pattern => {\n  let mask = {}\n  let len = pattern.length\n\n  for (let i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0\n  }\n\n  for (let i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] |= 1 << (len - i - 1)\n  }\n\n  return mask\n}","const bitapScore = require('./bitap-score')\nconst matchedIndices = require('./bitap-matched-indices')\n\nmodule.exports = (text, pattern, patternAlphabet, { location = 0, distance = 100, threshold = 0.6, findAllMatches = false, minMatchCharLength = 1, includeMatches = false }) => {\n  const patternLen = pattern.length\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length\n  // Handle the case when location > text.length\n  const expectedLocation = Math.max(0, Math.min(location, textLen))\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = text.indexOf(pattern, expectedLocation)\n\n  // a mask of the matches\n  const matchMask = []\n  for (let i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0\n  }\n\n  if (bestLocation !== -1) {\n    let score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation,\n      distance\n    })\n    currentThreshold = Math.min(score, currentThreshold)\n\n    // What about in the other direction? (speed up)\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen)\n\n    if (bestLocation !== -1) {\n      let score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation,\n        distance\n      })\n      currentThreshold = Math.min(score, currentThreshold)\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1\n\n  let lastBitArr = []\n  let finalScore = 1\n  let binMax = patternLen + textLen\n\n  const mask = 1 << (patternLen <= 31 ? patternLen - 1 : 30)\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0\n    let binMid = binMax\n\n    while (binMin < binMid) {\n      const score = bitapScore(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance\n      })\n\n      if (score <= currentThreshold) {\n        binMin = binMid\n      } else {\n        binMax = binMid\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin)\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid\n\n    let start = Math.max(1, expectedLocation - binMid + 1)\n    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2)\n\n    bitArr[finish + 1] = (1 << i) - 1\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1\n      let charMatch = patternAlphabet[text.charAt(currentLocation)]\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch\n\n      // Subsequent passes: fuzzy match\n      if (i !== 0) {\n        bitArr[j] |= (((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1) | lastBitArr[j + 1]\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance\n        })\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore\n          bestLocation = currentLocation\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation)\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = bitapScore(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance\n    })\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr\n  }\n\n  let result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: !finalScore ? 0.001 : finalScore,\n  }\n\n  if (includeMatches) {\n    result.matchedIndices = matchedIndices(matchMask, minMatchCharLength)\n  }\n\n  return result\n}\n","module.exports = (matchmask = [], minMatchCharLength = 1) => {\n  let matchedIndices = []\n  let start = -1\n  let end = -1\n  let i = 0\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i]\n    if (match && start === -1) {\n      start = i\n    } else if (!match && start !== -1) {\n      end = i - 1\n      if ((end - start) + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end])\n      }\n      start = -1\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && (i - start) >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices\n}\n","// Token: 'file\n// Match type: exact-match\n// Description: Items that include `file`\n\nconst isForPattern = pattern => pattern.charAt(0) == \"'\"\n\nconst sanitize = pattern => pattern.substr(1)\n\nconst match = (pattern, text) => {\n  const sanitizedPattern = sanitize(pattern)\n  const index = text.indexOf(sanitizedPattern)\n  const isMatch = index > -1\n\n  return {\n    isMatch,\n    score: 0,\n  }\n}\n\nmodule.exports = {\n  isForPattern,\n  sanitize,\n  match\n}","// Token: !fire\n// Match type: inverse-exact-match\n// Description: Items that do not include `fire`\n\nconst isForPattern = pattern => pattern.charAt(0) == '!'\n\nconst sanitize = pattern => pattern.substr(1)\n\nconst match = (pattern, text) => {\n  const sanitizedPattern = sanitize(pattern)\n  const isMatch = text.indexOf(sanitizedPattern) === -1\n\n  return {\n    isMatch,\n    score: 0\n  }\n}\n\nmodule.exports = {\n  isForPattern,\n  sanitize,\n  match\n}","// Token: ^file\n// Match type: prefix-exact-match\n// Description: Items that start with `file`\n\nconst isForPattern = pattern => pattern.charAt(0) == '^'\n\nconst sanitize = pattern => pattern.substr(1)\n\nconst match = (pattern, text) => {\n  const sanitizedPattern = sanitize(pattern)\n  const isMatch = text.startsWith(sanitizedPattern)\n\n  return {\n    isMatch,\n    score: 0\n  }\n}\n\nmodule.exports = {\n  isForPattern,\n  sanitize,\n  match\n}","// Token: !^fire\n// Match type: inverse-prefix-exact-match\n// Description: Items that do not start with `fire`\n\nconst isForPattern = pattern => pattern.charAt(0) == '!' && pattern.charAt(1) == '^'\n\nconst sanitize = pattern => pattern.substr(2)\n\nconst match = (pattern, text) => {\n  const sanitizedPattern = sanitize(pattern)\n  const isMatch = !text.startsWith(sanitizedPattern)\n\n  return {\n    isMatch,\n    score: 0\n  }\n}\n\nmodule.exports = {\n  isForPattern,\n  sanitize,\n  match\n}","// Token: .file$\n// Match type: suffix-exact-match\n// Description: Items that end with `.file`\n\nconst isForPattern = pattern => pattern.charAt(pattern.length - 1) == '$'\n\nconst sanitize = pattern => pattern.substr(0, pattern.length - 1)\n\nconst match = (pattern, text) => {\n  const sanitizedPattern = sanitize(pattern)\n  const isMatch = text.endsWith(sanitizedPattern)\n\n  return {\n    isMatch,\n    score: 0\n  }\n}\n\nmodule.exports = {\n  isForPattern,\n  sanitize,\n  match\n}","// Token: !.file$\n// Match type: inverse-suffix-exact-match\n// Description: Items that do not end with `.file`\n\nconst isForPattern = pattern => pattern.charAt(0) == '!' && pattern.charAt(pattern.length - 1) == '$'\n\nconst sanitize = pattern => pattern.substring(1, pattern.length - 1)\n\nconst match = (pattern, text) => {\n  const sanitizedPattern = sanitize(pattern)\n  const isMatch = !text.endsWith(sanitizedPattern)\n\n  return {\n    isMatch,\n    score: 0\n  }\n}\n\nmodule.exports = {\n  isForPattern,\n  sanitize,\n  match\n}","const INFINITY = 1 / 0\n\nconst isArray = value => !Array.isArray\n  ? Object.prototype.toString.call(value) === '[object Array]'\n  : Array.isArray(value)\n\n// Adapted from:\n// https://github.com/lodash/lodash/blob/f4ca396a796435422bd4fd41fadbd225edddf175/.internal/baseToString.js\nconst baseToString = value => {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  let result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nconst toString = value => value == null ? '' : baseToString(value);\n\nconst isString = value => typeof value === 'string'\n\nconst isNumber = value => typeof value === 'number'\n\nconst isObject = value => typeof value === 'object'\n\nconst isDefined = value => value !== undefined && value !== null\n\nmodule.exports = {\n  isDefined,\n  isArray,\n  isString,\n  isNumber,\n  isObject,\n  toString\n}\n","const exactMatch = require('./exact-match')\nconst inverseExactMatch = require('./inverse-exact-match')\nconst prefixExactMatch = require('./prefix-exact-match')\nconst inversePrefixExactMatch = require('./inverse-prefix-exact-match')\nconst suffixExactMatch = require('./suffix-exact-match')\nconst inverseSuffixExactMatch = require('./inverse-suffix-exact-match')\nconst BitapSearch = require('../bitap-search')\n\nconst { isString } = require('../../helpers/type-checkers')\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nconst queryfy = (pattern) => pattern.split('|').map(item => item.trim().split(/ +/g))\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that match `jscript`             |\n * | `'python`   | exact-match                | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nclass ExtendedSearch {\n  constructor(pattern, options) {\n    const { isCaseSensitive } = options\n    this.query = null\n    this.options = options\n    // A <pattern>:<BitapSearch> key-value pair for optimizing searching\n    this._fuzzyCache = {}\n\n    if (isString(pattern) && pattern.trim().length > 0) {\n      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase()\n      this.query = queryfy(this.pattern)\n    }\n  }\n\n  searchIn(value) {\n    const query = this.query\n\n    if (!this.query) {\n      return {\n        isMatch: false,\n        score: 1\n      }\n    }\n\n    let text = value.$\n\n    text = this.options.isCaseSensitive ? text : text.toLowerCase()\n\n    let matchFound = false\n\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n\n      const parts = query[i]\n      let result = null\n      matchFound = true\n\n      for (let j = 0, pLen = parts.length; j < pLen; j += 1) {\n        let token = parts[j]\n        result = this._search(token, text)\n        if (!result.isMatch) {\n          // AND condition, short-circuit and move on to next part\n          matchFound = false\n          break\n        }\n      }\n\n      // OR condition, so if TRUE, return\n      if (matchFound) {\n        return result\n      }\n    }\n\n    // Nothing was matched\n    return {\n      isMatch: false,\n      score: 1\n    }\n  }\n\n  _search(pattern, text) {\n    if (exactMatch.isForPattern(pattern)) {\n      return exactMatch.match(pattern, text)\n    } else if (prefixExactMatch.isForPattern(pattern)) {\n      return prefixExactMatch.match(pattern, text)\n    } else if (inversePrefixExactMatch.isForPattern(pattern)) {\n      return inversePrefixExactMatch.match(pattern, text)\n    } else if (inverseSuffixExactMatch.isForPattern(pattern)) {\n      return inverseSuffixExactMatch.match(pattern, text)\n    } else if (suffixExactMatch.isForPattern(pattern)) {\n      return suffixExactMatch.match(pattern, text)\n    } else if (inverseExactMatch.isForPattern(pattern)) {\n      return inverseExactMatch.match(pattern, text)\n    } else {\n      let searcher = this._fuzzyCache[pattern]\n      if (!searcher) {\n        searcher = new BitapSearch(pattern, this.options)\n        this._fuzzyCache[pattern] = searcher\n      }\n      return searcher.searchInString(text)\n    }\n  }\n}\n\nmodule.exports = ExtendedSearch","const NGRAM_LEN = 3\n\nmodule.exports = (text, { n = NGRAM_LEN, pad = true, sort = false }) => {\n  let nGrams = []\n\n  if (text === null || text === undefined) {\n    return nGrams\n  }\n\n  text = text.toLowerCase()\n  if (pad) {\n    text = ` ${text} `\n  }\n\n  let index = text.length - n + 1\n  if (index < 1) {\n    return nGrams\n  }\n\n  while (index--) {\n    nGrams[index] = text.substr(index, n)\n  }\n\n  if (sort) {\n    nGrams.sort((a, b) => a == b ? 0 : a < b ? -1 : 1)\n  }\n\n  return nGrams\n}","const { union, intersection } = require('../array-utils')\n\nmodule.exports = (nGram1, nGram2) => {\n  let nGramUnion = union(nGram1, nGram2)\n  let nGramIntersection = intersection(nGram1, nGram2)\n\n  return 1 - nGramIntersection.length / nGramUnion.length\n}","// Assumes arrays are sorted\nmodule.exports = (arr1, arr2) => {\n  let result = []\n  let i = 0\n  let j = 0\n\n  while (i < arr1.length && j < arr2.length) {\n    let item1 = arr1[i]\n    let item2 = arr2[j]\n\n    if (item1 < item2) {\n      result.push(item1)\n      i += 1\n    } else if (item2 < item1) {\n      result.push(item2)\n      j += 1\n    } else {\n      result.push(item2)\n      i += 1\n      j += 1\n    }\n  }\n\n  while (i < arr1.length) {\n    result.push(arr1[i])\n    i += 1\n  }\n\n  while (j < arr2.length) {\n    result.push(arr2[j])\n    j += 1\n  }\n\n  return result;\n}\n","// Assumes arrays are sorted\nmodule.exports = (arr1, arr2) => {\n  let result = []\n  let i = 0\n  let j = 0\n\n  while (i < arr1.length && j < arr2.length) {\n    let item1 = arr1[i]\n    let item2 = arr2[j]\n\n    if (item1 == item2) {\n      result.push(item1)\n      i += 1\n      j += 1\n    } else if (item1 < item2) {\n      i += 1\n    } else if (item1 > item2) {\n      j += 1\n    } else {\n      i += 1\n      j += 1\n    }\n  }\n\n  return result;\n}","const ngram = require('./ngram')\nconst { jaccardDistance } = require('./distance')\n\nclass NGramSearch {\n  constructor(pattern, options = { threshold: 0.6 }) {\n    // Create the ngram, and sort it\n    this.options = options\n    this.patternNgram = ngram(pattern, { sort: true })\n  }\n  searchIn(value) {\n    let textNgram = value.ng\n    if (!textNgram) {\n      textNgram = ngram(value.$, { sort: true })\n      value.ng = textNgram\n    }\n\n    let jacardResult = jaccardDistance(this.patternNgram, textNgram)\n\n    const isMatch = jacardResult < this.options.threshold\n\n    return {\n      score: isMatch ? jacardResult : 1,\n      isMatch\n    }\n  }\n}\n\nmodule.exports = NGramSearch","module.exports = {\n  BitapSearch: require('./bitap-search'),\n  ExtendedSearch: require('./extended-search'),\n  NGramSearch: require('./ngram-search')\n}","const {\n  isDefined,\n  isString,\n  isNumber,\n  isArray,\n  toString\n} = require('./type-checkers')\n\nmodule.exports = (obj, path) => {\n  let list = []\n  let arr = false\n\n  const _get = (obj, path) => {\n    if (!path) {\n      // If there's no path left, we've gotten to the object we care about.\n      list.push(obj)\n    } else {\n      const dotIndex = path.indexOf('.')\n\n      let key = path\n      let remaining = null\n\n      if (dotIndex !== -1) {\n        key = path.slice(0, dotIndex)\n        remaining = path.slice(dotIndex + 1)\n      }\n\n      const value = obj[key]\n\n      if (isDefined(value)) {\n        if (!remaining && (isString(value) || isNumber(value))) {\n          list.push(toString(value))\n        } else if (isArray(value)) {\n          arr = true\n          // Search each item in the array.\n          for (let i = 0, len = value.length; i < len; i += 1) {\n            _get(value[i], remaining)\n          }\n        } else if (remaining) {\n          // An object. Recurse further.\n          _get(value, remaining)\n        }\n      }\n    }\n  }\n\n  _get(obj, path)\n\n  if (arr) {\n    return list\n  }\n\n  return list[0]\n}","const { isArray, isDefined, isString } = require('../helpers/type-checkers')\nconst get = require('../helpers/get')\nconst ngram = require('../search/ngram-search/ngram')\n\nmodule.exports = (keys, list, { getFn = get, ngrams = false } = {}) => {\n  let indexedList = []\n\n  // List is Array<String>\n  if (isString(list[0])) {\n    // Iterate over every string in the list\n    for (let i = 0, len = list.length; i < len; i += 1) {\n      const value = list[i]\n\n      if (isDefined(value)) {\n        // if (!isCaseSensitive) {\n        //   value = value.toLowerCase()\n        // }\n\n        let record = {\n          $: value,\n          idx: i\n        }\n\n        if (ngrams) {\n          record.ng = ngram(value, { sort: true })\n        }\n\n        indexedList.push(record)\n      }\n    }\n\n  } else {\n    // List is Array<Object>\n    const keysLen = keys.length\n\n    for (let i = 0, len = list.length; i < len; i += 1) {\n      let item = list[i]\n\n      let record = { idx: i, $: {} }\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      for (let j = 0; j < keysLen; j += 1) {\n        let key = keys[j]\n        let value = getFn(item, key)\n\n        if (!isDefined(value)) {\n          continue\n        }\n\n        if (isArray(value)) {\n          let subRecords = []\n          const stack = [{ arrayIndex: -1, value }]\n\n          while (stack.length) {\n            const { arrayIndex, value } = stack.pop()\n\n            if (!isDefined(value)) {\n              continue\n            }\n\n            if (isString(value)) {\n\n              // if (!isCaseSensitive) {\n              //   v = v.toLowerCase()\n              // }\n\n              let subRecord = { $: value, idx: arrayIndex }\n\n              if (ngrams) {\n                subRecord.ng = ngram(value, { sort: true })\n              }\n\n              subRecords.push(subRecord)\n\n            } else if (isArray(value)) {\n              for (let k = 0, arrLen = value.length; k < arrLen; k += 1) {\n                stack.push({\n                  arrayIndex: k,\n                  value: value[k],\n                })\n              }\n            }\n          }\n          record.$[key] = subRecords\n        } else {\n          // if (!isCaseSensitive) {\n          //   value = value.toLowerCase()\n          // }\n\n          let subRecord = { $: value }\n\n          if (ngrams) {\n            subRecord.ng = ngram(value, { sort: true })\n          }\n\n          record.$[key] = subRecord\n        }\n      }\n\n      indexedList.push(record)\n    }\n  }\n\n  return indexedList\n}","const { isString } = require('../helpers/type-checkers')\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = {}\n    this._keyNames = []\n    this._length = keys.length\n\n    // Iterate over every key\n    if (keys.length && isString(keys[0])) {\n      for (let i = 0; i < this._length; i += 1) {\n        const key = keys[i]\n        this._keys[key] = {\n          weight: 1\n        }\n        this._keyNames.push(key)\n      }\n    } else {\n      let totalWeight = 0\n\n      for (let i = 0; i < this._length; i += 1) {\n        const key = keys[i]\n\n        if (!key.hasOwnProperty('name')) {\n          throw new Error('Missing \"name\" property in key object')\n        }\n\n        const keyName = key.name\n        this._keyNames.push(keyName)\n\n        if (!key.hasOwnProperty('weight')) {\n          throw new Error('Missing \"weight\" property in key object')\n        }\n\n        const weight = key.weight\n\n        if (weight <= 0 || weight >= 1) {\n          throw new Error('\"weight\" property in key must bein the range of (0, 1)')\n        }\n\n        this._keys[keyName] = {\n          weight\n        }\n\n        totalWeight += weight\n      }\n\n      // Normalize weights so that their sum is equal to 1\n      for (let i = 0; i < this._length; i += 1) {\n        const keyName = this._keyNames[i]\n        const keyWeight = this._keys[keyName].weight\n        this._keys[keyName].weight = keyWeight / totalWeight\n      }\n    }\n  }\n  get(key, name) {\n    return this._keys[key] ? this._keys[key][name] : -1\n  }\n  keys() {\n    return this._keyNames\n  }\n  count() {\n    return this._length\n  }\n  toJSON() {\n    return JSON.stringify(this._keys)\n  }\n}\n\nmodule.exports = KeyStore","module.exports = {\n  createIndex: require('./create-index'),\n  KeyStore: require('./key-store')\n}","const { isArray, isDefined, isString, isNumber, isObject } = require('../helpers/type-checkers')\n\nmodule.exports = (result, data) => {\n  const matches = result.matches\n  data.matches = []\n\n  if (!isDefined(matches)) {\n    return\n  }\n\n  for (let i = 0, len = matches.length; i < len; i += 1) {\n    let match = matches[i]\n\n    if (!isDefined(match.indices) || match.indices.length === 0) {\n      continue\n    }\n\n    let obj = {\n      indices: match.indices,\n      value: match.value\n    }\n\n    if (match.key) {\n      obj.key = match.key\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx\n    }\n\n    data.matches.push(obj)\n  }\n}\n","\nconst { BitapSearch, ExtendedSearch, NGramSearch } = require('./search')\nconst { isArray, isDefined, isString, isNumber, isObject } = require('./helpers/type-checkers')\nconst get = require('./helpers/get')\nconst { createIndex, KeyStore } = require('./tools')\nconst { transformMatches, transformScore } = require('./transform')\nconst { MAX_BITS } = require('./search/bitap-search/constants')\n\n// // Will print to the console. Useful for debugging.\n// function debug() {\n//   if (Fuse.verbose) {\n//     console.log(...arguments)\n//     // const util = require('util')\n//     // console.log(util.inspect(...arguments, false, null, true /* enable colors */))\n//   }\n// }\n\n// function debugTime(value) {\n//   if (Fuse.verboseTime) {\n//     console.time(value)\n//   }\n// }\n\n// function debugTimeEnd(value) {\n//   if (Fuse.verboseTime) {\n//     console.timeEnd(value)\n//   }\n// }\n\nlet FuseOptions = {\n  // When true, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100,\n  // Minimum number of characters that must be matched before a result is considered a match\n  findAllMatches: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  includeMatches: false,\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1,\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function\n  sortFn: (a, b) => (a.score - b.score),\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Enabled extended-searching\n  useExtendedSearch: false\n}\n\nclass Fuse {\n  constructor(list, options = FuseOptions, index = null) {\n    this.options = { ...FuseOptions, ...options }\n    // `caseSensitive` is deprecated, use `isCaseSensitive` instead\n    this.options.isCaseSensitive = options.caseSensitive\n    delete this.options.caseSensitive\n\n    // debugTime('Constructing')\n    this._processKeys(this.options.keys)\n    this.setCollection(list, index)\n    // debugTimeEnd('Constructing')\n  }\n\n  setCollection(list, index = null) {\n    this.list = list\n    this.listIsStringArray = isString(list[0])\n\n    if (index) {\n      this.setIndex(index)\n    } else {\n      // debugTime('Process index')\n      this.setIndex(this._createIndex())\n      // debugTimeEnd('Process index')\n    }\n  }\n\n  setIndex(listIndex) {\n    this._indexedList = listIndex\n    // debug(listIndex)\n  }\n\n  _processKeys(keys) {\n    this._keyStore = new KeyStore(keys)\n\n    // debug('Process Keys')\n    if (Fuse.verbose) {\n      // debug(this._keyStore.toJSON())\n    }\n  }\n\n  _createIndex() {\n    return createIndex(this._keyStore.keys(), this.list, {\n      getFn: this.options.getFn\n    })\n  }\n\n  search(pattern, opts = { limit: false }) {\n    // debug(`--------- Search pattern: \"${pattern}\"`)\n    const { useExtendedSearch, shouldSort } = this.options\n\n    let searcher = null\n\n    if (useExtendedSearch) {\n      searcher = new ExtendedSearch(pattern, this.options)\n    } else if (pattern.length > MAX_BITS) {\n      searcher = new NGramSearch(pattern, this.options)\n    } else {\n      searcher = new BitapSearch(pattern, this.options)\n    }\n\n    // debugTime('Search time');\n    let results = this._searchUsing(searcher)\n    // debugTimeEnd('Search time');\n\n    // debugTime('Compute score time');\n    this._computeScore(results)\n    // debugTimeEnd('Compute score time');\n\n    if (shouldSort) {\n      this._sort(results)\n    }\n\n    if (opts.limit && isNumber(opts.limit)) {\n      results = results.slice(0, opts.limit)\n    }\n\n    return this._format(results)\n  }\n\n  _searchUsing(searcher) {\n    const list = this._indexedList\n    const results = []\n    const { includeMatches } = this.options\n\n    // List is Array<String>\n    if (this.listIsStringArray) {\n      // Iterate over every string in the list\n      for (let i = 0, len = list.length; i < len; i += 1) {\n        let value = list[i]\n        let { $: text, idx } = value\n\n        if (!isDefined(text)) {\n          continue\n        }\n\n        let searchResult = searcher.searchIn(value)\n\n        const { isMatch, score } = searchResult\n\n        if (!isMatch) {\n          continue\n        }\n\n        let match = { score, value: text }\n\n        if (includeMatches) {\n          match.indices = searchResult.matchedIndices\n        }\n\n        results.push({\n          item: text,\n          idx,\n          matches: [match]\n        })\n      }\n\n    } else {\n      // List is Array<Object>\n      const keyNames = this._keyStore.keys()\n      const keysLen = this._keyStore.count()\n\n      for (let i = 0, len = list.length; i < len; i += 1) {\n        let { $: item, idx } = list[i]\n\n        if (!isDefined(item)) {\n          continue\n        }\n\n        let matches = []\n\n        // Iterate over every key (i.e, path), and fetch the value at that key\n        for (let j = 0; j < keysLen; j += 1) {\n          let key = keyNames[j]\n          let value = item[key]\n\n          // debug(` Key: ${key === '' ? '--' : key}`)\n\n          if (!isDefined(value)) {\n            continue\n          }\n\n          if (isArray(value)) {\n            for (let k = 0, len = value.length; k < len; k += 1) {\n              let arrItem = value[k]\n              let text = arrItem.$\n              let idx = arrItem.idx\n\n              if (!isDefined(text)) {\n                continue\n              }\n\n              let searchResult = searcher.searchIn(arrItem)\n\n              const { isMatch, score } = searchResult\n\n              // debug(`Full text: \"${text}\", score: ${score}`)\n\n              if (!isMatch) {\n                continue\n              }\n\n              let match = { score, key, value: text, idx }\n\n              if (includeMatches) {\n                match.indices = searchResult.matchedIndices\n              }\n\n              matches.push(match)\n            }\n          } else {\n            let text = value.$\n            let searchResult = searcher.searchIn(value)\n\n            const { isMatch, score } = searchResult\n\n            // debug(`Full text: \"${text}\", score: ${score}`)\n\n            if (!isMatch) {\n              continue\n            }\n\n            let match = { score, key, value: text }\n\n            if (includeMatches) {\n              match.indices = searchResult.matchedIndices\n            }\n\n            matches.push(match)\n          }\n        }\n\n        if (matches.length) {\n          results.push({\n            idx,\n            item,\n            matches\n          })\n        }\n      }\n    }\n\n    // debug(\"--------- RESULTS -----------\")\n    // debug(results)\n    // debug(\"-----------------------------\")\n\n    return results\n  }\n\n  _computeScore(results) {\n    // debug('Computing score: ')\n\n    for (let i = 0, len = results.length; i < len; i += 1) {\n      const result = results[i]\n      const matches = result.matches\n      const scoreLen = matches.length\n\n      let totalWeightedScore = 1\n      // let bestScore = -1\n\n      for (let j = 0; j < scoreLen; j += 1) {\n        const item = matches[j]\n        const key = item.key\n        const keyWeight = this._keyStore.get(key, 'weight')\n        const weight = keyWeight > -1 ? keyWeight : 1\n        const score = item.score === 0 && keyWeight > -1\n          ? Number.EPSILON\n          : item.score\n\n        totalWeightedScore *= Math.pow(score, weight)\n\n        // Keep track of the best score.. just in case\n        // Actually, we're not really using it.. but need to think of a way to incorporate this\n        // bestScore = bestScore == -1 ? item.score : Math.min(bestScore, item.score)\n      }\n\n      result.score = totalWeightedScore\n      // result.$score = bestScore\n\n      // debug(result)\n    }\n  }\n\n  _sort(results) {\n    // debug('Sorting....')\n    results.sort(this.options.sortFn)\n  }\n\n  _format(results) {\n    const finalOutput = []\n\n    const { includeMatches, includeScore, } = this.options\n\n    // if (Fuse.verbose) {\n    //   let cache = []\n    //   debug('Output:', JSON.stringify(results, (key, value) => {\n    //     if (isObject(value) && isDefined(value)) {\n    //       if (cache.indexOf(value) !== -1) {\n    //         // Circular reference found, discard key\n    //         return\n    //       }\n    //       // Store value in our collection\n    //       cache.push(value)\n    //     }\n    //     return value\n    //   }, 2))\n    //   cache = null\n    // }\n\n    let transformers = []\n\n    if (includeMatches) transformers.push(transformMatches)\n    if (includeScore) transformers.push(transformScore)\n\n    // debug(\"===== RESULTS ======\")\n    // debug(results)\n    // debug(\"====================\")\n\n    for (let i = 0, len = results.length; i < len; i += 1) {\n      const result = results[i]\n\n      // debug('result', result)\n\n      const { idx } = result\n\n      const data = {\n        item: this.list[idx],\n        refIndex: idx\n      }\n\n      if (transformers.length) {\n        for (let j = 0, len = transformers.length; j < len; j += 1) {\n          transformers[j](result, data)\n        }\n      }\n\n\n      finalOutput.push(data)\n    }\n\n    return finalOutput\n  }\n}\n\nFuse.createIndex = createIndex\n\nmodule.exports = Fuse\n","module.exports = (result, data) => {\n  data.score = result.score\n}"],"names":["pattern","errors","currentLocation","expectedLocation","distance","accuracy","length","proximity","Math","abs","MAX_BITS","require$$0","location","threshold","isCaseSensitive","findAllMatches","minMatchCharLength","includeMatches","options","Error","toLowerCase","patternAlphabet","mask","len","i","charAt","this","value","text","$","searchInString","result","isMatch","score","matchedIndices","patternLen","textLen","max","min","currentThreshold","bestLocation","indexOf","matchMask","bitapScore","lastIndexOf","lastBitArr","finalScore","binMax","binMin","binMid","floor","start","finish","bitArr","Array","j","charMatch","matchmask","end","match","push","bitapSearch","sanitize","substr","sanitizedPattern","startsWith","endsWith","substring","isArray","Object","prototype","toString","call","baseToString","isString","ExtendedSearch","query","_fuzzyCache","trim","split","map","item","queryfy","matchFound","qLen","parts","pLen","token","_search","exactMatch","prefixExactMatch","inversePrefixExactMatch","inverseSuffixExactMatch","suffixExactMatch","inverseExactMatch","searcher","BitapSearch","n","pad","sort","nGrams","index","a","b","union","arr1","arr2","item1","item2","intersection","jaccardDistance","nGram1","nGram2","nGramUnion","NGramSearch","patternNgram","ngram","textNgram","ng","jacardResult","isDefined","isNumber","obj","path","list","arr","_get","dotIndex","key","remaining","slice","createIndex","keys","getFn","get","ngrams","indexedList","record","idx","keysLen","subRecords","stack","arrayIndex","pop","subRecord","k","arrLen","KeyStore","_keys","_keyNames","_length","weight","totalWeight","hasOwnProperty","keyName","name","keyWeight","JSON","stringify","require$$1","require$$2","transformMatches","data","matches","indices","refIndex","transformScore","require$$4","FuseOptions","includeScore","shouldSort","sortFn","useExtendedSearch","Fuse","caseSensitive","_processKeys","setCollection","listIsStringArray","setIndex","_createIndex","listIndex","_indexedList","_keyStore","opts","limit","results","_searchUsing","_computeScore","_sort","_format","searchResult","searchIn","keyNames","count","arrItem","scoreLen","totalWeightedScore","Number","EPSILON","pow","finalOutput","transformers"],"mappings":"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"}